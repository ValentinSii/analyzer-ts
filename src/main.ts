import { getCUrrentDate, normalizeArray } from './helpers/normalize';
import { PlaywrightScraper } from "./scraper/PlaywrightScraper";
import { Input, Output } from "../src/types";
import { searchData } from './search/Search';
import { Validator } from './validation/Validator';
import { readFileSync } from "fs";
import { KeyValueStore, log } from '@crawlee/core';
import { Actor } from 'apify';
import { crawl } from './crawl/Crawler';
import { parse, html } from "diff2html";
import { createTwoFilesPatch } from 'diff';
/*
 * Actor's entry point. 
 */
(async () => {
    Actor.init();
    log.setLevel(log.LEVELS.DEBUG);

    const output = new Output();
    output.analysisStarted = getCUrrentDate();

    // let store:KeyValueStore;
    let input: Input;
    try {
        // try to load the INPUT.json from default kvs
        try {
            // Structure of the input is defined in /INPUT_SCHEMA.json.
            // This function expects INPUT.json file in the default key-value store
            // which defaults to /storage/key_value_stores/default.
            input = await KeyValueStore.getInput() as Input;
            if (input == null) {
                throw new Error("Input is null.")
            }
        } catch (e: any) {
            log.error("Failed to load the input");
            log.error(e.message);
            output.actorSuccess = false;
            throw e;
        }
        // TODO: only save the output of analyzer to default kvs in production
        try {
            // store = await Actor.openKeyValueStore(`runs/${dayjs(new Date()).format('YYYY-MM-DD-HH-mm-ss')}`);
            // await store.setValue("INPUT", JSON.stringify(input!), { contentType: "application/json; charset=utf-8" });
        } catch (e: any) {
            log.error('Failed to create a key-value store with the current date');
            log.error(e.message);
            log.debug("Using default store.");
        }

        const normalizedKeywords = normalizeArray(input.keywords);

        // TODO: analyze url and query parameters
        const params = new URLSearchParams(input.url);
        output.setInput(input.url, normalizedKeywords);

        // Copy frontend application to keyvalue store, this file is generated by project analyzer-ui, mentioned in the readme.
        // On the Apify platform, this file is copied during actor's build in docker.
        await KeyValueStore.setValue("DASHBOARD", readFileSync("./src/static/index.html"), { contentType: 'text/html; charset=utf-8' });
        // await store!.setValue("DASHBOARD", readFileSync("./src/static/index.html"), { contentType: 'text/html; charset=utf-8' });

        // TODO: fix formatting
        log.info("INPUT", input);
        log.info('===================================================================================================================');
        log.info('Welcome to the page analyzer!');
        log.info('URL: ' + input.url);
        log.info('KEYWORDS: ' + input.keywords);
        log.info('===================================================================================================================');
        output.analysisStarted = getCUrrentDate();

        // navigate to the website
        const scraper = new PlaywrightScraper(input.url, normalizedKeywords);
        // scrape and parse the data 
        const scrapedData = await scraper.scrapePage(true, true);

        // after the data is loaded and parsed we can search for keywords 
        const searchResults = searchData(scrapedData, normalizedKeywords);

        // generate deff initial response -> rendered document
        try {
            const difdiff = createTwoFilesPatch("", "", scrapedData.initial!.body, scrapedData!.DOM!.body, "Initial response", "Rendered document");
            const diffJson = parse(difdiff);
            const diffHtml = html(diffJson, { outputFormat: 'side-by-side', drawFileList: false });
            // log.debug(diffHtml);
            await KeyValueStore.setValue("diff", diffHtml, { contentType: 'application/html; charset=utf-8' });
            // await store!.setValue("diff", diffHtml, { contentType: 'application/html; charset=utf-8' });

        } catch (e: any) {
            log.debug("Failed to create the diff of initial response and rendered document:");
            console.log(e.message);
        }

        // close the browser
        // scraper.close();

        // retrieve initial response with the CheerioCrawler and validate the search results
        const validator = new Validator();
        const validatedData = await validator.validate(input.url, normalizedKeywords, searchResults);

        // save the output
        output.scrapedData = scrapedData;
        output.searchResults = searchResults;
        output.keywordConclusions = validatedData.conclusion;
        output.xhrValidated = validatedData.xhrValidated;
        output.cheerioCrawlerSuccess = validatedData.cheerioCrawlerSuccess;
        output.scrapedData.parsedCheerio = validatedData.parsedCheerio;

        try {
            // TODO: delete other redundant properties from the OUTPUT.json
            output.scrapedData!.initial!.body = null;
            output.scrapedData!.DOM!.body = null;
        } catch (e: any) {
            log.error(e);
        }

        // TODO: create and run the crawler
        // await crawl(input.url, output.keywordConclusions);

        // error for testing purposes
        // throw new Error("Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.")


    } catch (e: any) {
        log.error('Top lever error inside main:');
        log.error(e);
        console.error(e);
        output.actorSuccess = false;
        output.errorMessage = e.message;
    } finally {

        output.analysisEnded = getCUrrentDate();

        await KeyValueStore.setValue("OUTPUT", JSON.stringify(output!, null, 2), { contentType: 'application/json; charset=utf-8' });
        // await store!.setValue("OUTPUT", JSON.stringify(output!, null, 2), { contentType: 'application/json; charset=utf-8' });
    }

    Actor.exit({ exitCode: output.actorSuccess ? 0 : 1 });
})();
